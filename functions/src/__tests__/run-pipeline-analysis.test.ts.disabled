/**
 * Pipeline Analysis Test Runner
 * 
 * Runs comprehensive analysis of the document generation pipeline
 * to identify the root cause of 500 errors.
 */

import { describe, it, expect, beforeEach, afterEach, jest } from "@jest/globals"
// import { runPipelineAnalysis, PipelineAnalyzer } from "./analyze-pipeline"

// Mock all external dependencies
jest.mock("../services/generator.service")
jest.mock("../services/content-item.service")
jest.mock("../services/pdf.service")
jest.mock("../services/storage.service")
jest.mock("../services/ai-provider.factory")
jest.mock("@google-cloud/firestore")
jest.mock("@google-cloud/secret-manager")

describe("Pipeline Analysis Test Runner", () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  afterEach(() => {
    jest.restoreAllMocks()
  })

  describe("Comprehensive Pipeline Analysis", () => {
    it("should run complete pipeline analysis", async () => {
      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Verify analysis results structure
      expect(results).toHaveProperty("failurePoints")
      expect(results).toHaveProperty("recommendations")
      expect(results).toHaveProperty("testResults")

      // Verify failure points are identified
      expect(Array.isArray(results.failurePoints)).toBe(true)
      expect(Array.isArray(results.recommendations)).toBe(true)
      expect(Array.isArray(results.testResults)).toBe(true)

      // Log results for debugging
      console.log("🔍 Pipeline Analysis Results:")
      console.log("Failure Points:", results.failurePoints)
      console.log("Recommendations:", results.recommendations)
      console.log("Test Results:", results.testResults)
    })

    it("should identify environment variable issues", async () => {
      // Test with missing environment variables
      const originalEnv = process.env
      process.env = { ...originalEnv }
      delete process.env.GEMINI_API_KEY
      delete process.env.OPENAI_API_KEY

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Should identify environment variable issues
      expect(results.failurePoints).toContain("Environment Variables")
      expect(results.recommendations).toContain("Ensure all required environment variables are set")

      process.env = originalEnv
    })

    it("should identify database connection issues", async () => {
      // Mock database connection failure
      const mockGeneratorService = await import("../services/generator.service")
      jest.mocked(mockGeneratorService.GeneratorService).mockImplementation(() => {
        throw new Error("Database connection failed")
      })

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Should identify database connection issues
      expect(results.failurePoints).toContain("Database Connection")
      expect(results.recommendations).toContain("Check Firestore connection and permissions")
    })

    it("should identify AI provider issues", async () => {
      // Mock AI provider initialization failure
      const mockAIProviderFactory = await import("../services/ai-provider.factory")
      jest.mocked(mockAIProviderFactory.createAIProvider).mockRejectedValue(
        new Error("AI provider initialization failed")
      )

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Should identify AI provider issues
      expect(results.failurePoints).toContain("AI Provider Initialization")
      expect(results.recommendations).toContain("Verify AI provider configuration and API keys")
    })

    it("should identify PDF generation issues", async () => {
      // Mock PDF generation failure
      const mockPDFService = await import("../services/pdf.service")
      jest.mocked(mockPDFService.PDFService).mockImplementation(() => {
        throw new Error("PDF generation failed")
      })

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Should identify PDF generation issues
      expect(results.failurePoints).toContain("PDF Generation")
      expect(results.recommendations).toContain("Check PDF service configuration and dependencies")
    })

    it("should identify storage upload issues", async () => {
      // Mock storage upload failure
      const mockStorageService = await import("../services/storage.service")
      jest.mocked(mockStorageService.StorageService).mockImplementation(() => {
        throw new Error("Storage upload failed")
      })

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Should identify storage upload issues
      expect(results.failurePoints).toContain("Storage Upload")
      expect(results.recommendations).toContain("Verify storage service configuration and permissions")
    })

    it("should identify personal info issues", async () => {
      // Mock missing personal info
      const mockGeneratorService = await import("../services/generator.service")
      jest.mocked(mockGeneratorService.GeneratorService).mockImplementation(() => ({
        getPersonalInfo: jest.fn().mockResolvedValue(null),
      } as any))

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Should identify personal info issues
      expect(results.failurePoints).toContain("Personal Info Missing")
      expect(results.recommendations).toContain("Ensure personal info is properly configured")
    })

    it("should identify intermediate results issues", async () => {
      // Mock missing intermediate results
      const mockGeneratorService = await import("../services/generator.service")
      jest.mocked(mockGeneratorService.GeneratorService).mockImplementation(() => ({
        getRequest: jest.fn().mockResolvedValue({
          id: "test-request",
          status: "processing",
          steps: [
            { id: "fetch_data", name: "Fetch Data", status: "completed" },
            { id: "generate_resume", name: "Generate Resume", status: "completed" },
          ],
          intermediateResults: {
            // Missing resumeContent
          },
        }),
      } as any))

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Should identify intermediate results issues
      expect(results.failurePoints).toContain("Intermediate Results Missing")
      expect(results.recommendations).toContain("Check step execution and data flow")
    })

    it("should identify service dependency issues", async () => {
      // Mock service dependency failure
      const mockGeneratorService = await import("../services/generator.service")
      jest.mocked(mockGeneratorService.GeneratorService).mockImplementation(() => {
        throw new Error("Service dependency failed")
      })

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Should identify service dependency issues
      expect(results.failurePoints).toContain("Service Dependencies")
      expect(results.recommendations).toContain("Verify all service dependencies are properly configured")
    })
  })

  describe("Analysis Report Generation", () => {
    it("should generate comprehensive analysis report", async () => {
      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Generate analysis report
      const report = {
        timestamp: new Date().toISOString(),
        totalTests: results.testResults.length,
        passedTests: results.testResults.filter(test => test.passed).length,
        failedTests: results.testResults.filter(test => !test.passed).length,
        failurePoints: results.failurePoints,
        recommendations: results.recommendations,
        testResults: results.testResults,
      }

      // Verify report structure
      expect(report).toHaveProperty("timestamp")
      expect(report).toHaveProperty("totalTests")
      expect(report).toHaveProperty("passedTests")
      expect(report).toHaveProperty("failedTests")
      expect(report).toHaveProperty("failurePoints")
      expect(report).toHaveProperty("recommendations")
      expect(report).toHaveProperty("testResults")

      // Log report for debugging
      console.log("📊 Analysis Report:", JSON.stringify(report, null, 2))
    })

    it("should provide actionable recommendations", async () => {
      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Verify recommendations are actionable
      results.recommendations.forEach(rec => {
        expect(rec).toMatch(/^(Ensure|Check|Verify|Fix|Update|Configure)/)
        expect(rec.length).toBeGreaterThan(10)
      })

      // Log recommendations for debugging
      console.log("💡 Recommendations:", results.recommendations)
    })
  })

  describe("Error Pattern Recognition", () => {
    it("should recognize common error patterns", async () => {
      const commonErrors = [
        "Environment Variables",
        "Database Connection",
        "AI Provider Initialization",
        "PDF Generation",
        "Storage Upload",
        "Personal Info Missing",
        "Intermediate Results Missing",
        "Service Dependencies",
      ]

      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Check if any common errors are identified
      const identifiedErrors = results.failurePoints.filter(point => 
        commonErrors.includes(point)
      )

      expect(identifiedErrors.length).toBeGreaterThanOrEqual(0)
      console.log("🔍 Identified Common Errors:", identifiedErrors)
    })

    it("should prioritize critical failure points", async () => {
      const analyzer = new PipelineAnalyzer()
      const results = await analyzer.analyzePipeline()

      // Critical failure points that should be prioritized
      const criticalPoints = [
        "Environment Variables",
        "Database Connection",
        "AI Provider Initialization",
      ]

      const criticalFailures = results.failurePoints.filter(point => 
        criticalPoints.includes(point)
      )

      if (criticalFailures.length > 0) {
        console.log("🚨 Critical Failures Identified:", criticalFailures)
        expect(criticalFailures.length).toBeGreaterThan(0)
      }
    })
  })
})
